/*

Validation Errors dynamic example.

This is a dynamic validation error example, it will generate a validation error
for each field for the objecttype "validation_errors"  if the field is not empty.
And for reverse fields it will generate a validation error if the value of the field starts with "_"

The general rules for the field names are:
 - Normal Fields : <objecttype_name>.<field_name>
 - Nested Fields : <objecttype_name>.<nested_field_name>[<index>].<sub_field_name>
 - Reversed nested tables : <reverse_objecttype_name>.<reverse_field_name>[<index>].<field_name>

 On nesteds if the "[]" is used without any number then we are referencing the nested field itself as a whole

An example of a response with validation errors generated by this script is:

{
    "code": "validation.plugin.error",
    "error": "Server Validation Error, see editor for details",
    "package": "",
    "parameters": {
        "problems": [
            [
                {
                    "field": "myobjecttype.field_list[0].subfield_1",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.field_list[]",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.name",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
                {
                    // Note that for reverse nested fields we use first the reverse objecttype name and then the reverse field name
                    "field": "otherObjectType.reverse_field[0].name",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
            ]
        ]
    },
    "realm": "api",
    "statuscode": 400
}


*/



const fs = require('fs');


let input = '';
process.stdin.on('data', d => {
    try {
        input += d.toString();
    } catch(e) {
        console.error(`Could not read input into string: ${e.message}`, e.stack);
        process.exit(1);
    }
});


process.stdin.on('end', () => {

    isEmpty = (obj) => {
        //if its an array
        if (Array.isArray(obj)) {
            return obj.length === 0;
        }
        //if its an object
        if (typeof obj === 'object') {
            for (const key in obj) {
                if (obj.hasOwnProperty(key)) {
                    return false;
                }
            }
            return true;
        }
        //if its a string
        else if (typeof obj === 'string') {
            return obj.length === 0 || obj === "<null>"
        }
        // Everything else
        else {
            return !obj;
        }
    }

    // We get the objects being saved from input
    const objects = JSON.parse(input)?.objects;
    if (!objects || !objects.length > 0) {
        process.exit(1);
    }

    const objecttype = objects[0]["_objecttype"];
    let problemsCount = 0;

    const errors = objects.map(o => {

        checkField = (fieldName, fieldValue, prePath=null, preFieldName = null) => {

            if (fieldName.startsWith("_") && !fieldName.startsWith("_nested") && !fieldName.startsWith("_reverse_nested") ) {
               return;
            }

            // Demo nested errors
            if (fieldName.startsWith("_nested") && fieldValue.length > 0) {
                let nestedProblemsCount = 0;
                let idx = 0;
                fieldValue.forEach( nestedObject => {
                    for (const nestedFieldName in nestedObject) {
                        const nestedFieldValue = nestedObject[nestedFieldName];

                        // Here we build the full path of the field but without some string that ez5 add like __ or _nested__ etc..
                        let n = nestedFieldName.startsWith("_nested") ? nestedFieldName.substring(fieldName.length + 2) + "[]" : nestedFieldName;
                        let f = fieldName.substring(10 + objecttype.length);

                        // We need to build the full path of the field we use the prePath and preFieldName to build it, if any
                        let pre = prePath ? prePath : objecttype;
                        if (preFieldName) {
                            // n start with prefieldname + "__"?
                            f = f.startsWith(preFieldName + "__") ?  f.substring(preFieldName.length + 2) : f;
                        }

                        // The cleaned path that will be sent with the error to the frontend
                        fullPath = pre + "." + f + "[" + idx + "]." + n;

                        if (!isEmpty(nestedFieldValue)) {
                            // We recursively check the nested fields, we pass the full path of the field
                            // and the name of the parent field to build the full path of the nested field
                            fullPath = pre + "." + f + "[" + idx + "]";
                            checkField(nestedFieldName, nestedFieldValue, fullPath, f);
                            continue;
                        }

                        e.push({
                            "field": fullPath,
                            "message": `Error on  **${nestedFieldName}** with value, fields can't be empty`,
                            "parameters": {
                                a: "a",
                                b: "b",
                            }
                        });
                        nestedProblemsCount++;
                        problemsCount++;
                    }
                    idx++;
                });

                // For a validation error for the nested table itself we can use <subtable_name>[] as field name
                if(nestedProblemsCount>0) {
                    const newNestedFieldName = fieldName.substring(10 + objecttype.length) + "[]";
                    e.push({
                        "field": objecttype + "." + newNestedFieldName,
                        "message": `There are errors inside **${newNestedFieldName}**`
                    });
                }

            } else if (fieldName.startsWith("_reverse_nested") && fieldValue.length > 0) {
                // Reverse nested fields, the reverse nested is like _reverse_nested_<linked_table>:<field_name>
                const reverseTableName = fieldName.split(":")[1];
                const reverseFieldName = fieldName.split(":")[2];
                let reverseProblemsCount = 0;
                let idx = 0;
                fieldValue.forEach(nestedReversedObject => {
                    // We iterate the fields of the reverse nested object
                    for (const nestedFieldName in nestedReversedObject) {


                        if (nestedFieldName.startsWith("_")) {
                            continue;
                        }

                        e.push(
                            {
                                "message": `${nestedFieldName} : ${nestedReversedObject[nestedFieldName]}`
                            }
                        )

                        if (!nestedReversedObject[nestedFieldName].startsWith("_")) {
                            continue;
                        }

                        // For reverse nested fields we validate that the user dont send a value starting with _

                        e.push({
                            "field": reverseTableName + "." + reverseFieldName + "[" + idx + "]." + nestedFieldName,
                            "message": `Error for  **${nestedFieldName}** in **${reverseFieldName}**, fields cant start with _`,
                        });
                        reverseProblemsCount++;
                    }
                    idx++;
                });

                if(reverseProblemsCount>0) {
                    e.push({
                        "field": reverseTableName + "." + reverseFieldName + "[]",
                        "message": `There is a problem on the field: **${fieldName}**`,
                    });
                }

            } else {

                if (!isEmpty(fieldValue)) {
                    return;
                }

                fieldPath = prePath ? prePath + "." + fieldName : objecttype + "." + fieldName;
                // Not nested fields
                e.push({
                    "field": fieldPath,
                    "message": `The field **${fieldName}** can't be empty values`,
                    "parameters": {
                        a: "a",
                        b: "b",
                    }
                });
                problemsCount++;
            }

        }



        let e = [];
        for (const fieldName in o[objecttype]) {
            checkField(fieldName, o[objecttype][fieldName]);
        }
        return e;
    });

    if (problemsCount === 0) {
        console.log(JSON.stringify({"objects": []}));
        console.error("Validation ok");
        process.exit(0);
        return
    }

    console.log(JSON.stringify(
        {
            "code": "validation.plugin.error",
            "error": "Server Validation Error, see editor for details",
            "statuscode": 400,
            "parameters": {
                "problems": errors,
            }
        }
    ));
    console.error("This error goes to STDERR")
    process.exit(400);
});
