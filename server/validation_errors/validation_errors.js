/*

Validation Errors dynamic example.

This is a dynamic validation error example, it will generate a validation error
for each field for the objecttype "validation_errors"  if the field is not empty.
With this example you can easily test the validation error handling in the editor for all fields.

The general rules for the field names are:
 - Normal Fields : <objecttype_name>.<field_name>
 - Nested Fields : <objecttype_name>.<nested_field_name>[<index>].<sub_field_name>
 - Reversed nested tables : <reverse_objecttype_name>.<reverse_field_name>[<index>].<field_name>

 On nesteds if the "[]" is used without any number then we are referencing the nested field itself as a whole

An example of a response with validation errors generated by this script is:

{
    "code": "validation.plugin.error",
    "error": "Server Validation Error, see editor for details",
    "package": "",
    "parameters": {
        "problems": [
            [
                {
                    "field": "myobjecttype.field_list[0].subfield_1",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.field_list[]",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.name",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
                {
                    // Note that for reverse nested fields we use first the reverse objecttype name and then the reverse field name
                    "field": "otherObjectType.reverse_field[0].name",
                    "message": "message of the error",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
            ]
        ]
    },
    "realm": "api",
    "statuscode": 400
}


*/



const fs = require('fs');


let input = '';
process.stdin.on('data', d => {
    try {
        input += d.toString();
    } catch(e) {
        console.error(`Could not read input into string: ${e.message}`, e.stack);
        process.exit(1);
    }
});


process.stdin.on('end', () => {
    // We get the objects being saved from input
    const objects = JSON.parse(input)?.objects;
    if (!objects || !objects.length > 0) {
        process.exit(1);
    }

    const objecttype = objects[0]["_objecttype"];
    let problemsCount = 0;
    const errors = objects.map(o => {
        let e = [];
        for (const fieldName in o[objecttype]) {
            if (fieldName.startsWith("_") && !fieldName.startsWith("_nested") && !fieldName.startsWith("_reverse_nested") ) {
                continue;
            }
            const fieldValue = o[objecttype][fieldName];
            if (fieldValue === null || fieldValue === undefined || fieldValue === "") {
                continue;
            }

            // Demo nested errors
            if (fieldName.startsWith("_nested") && fieldValue.length > 0) {
                let nestedProblemsCount = 0;
                let idx = 0;
                fieldValue.forEach(nestedObject => {
                    for (const nestedFieldName in nestedObject) {
                        const nestedFieldValue = nestedObject[nestedFieldName];
                        if (nestedFieldValue === null) {
                            continue;
                        }

                        const n = nestedFieldName.startsWith("_nested") ? nestedFieldName.substring(fieldName.length + 2) + "[]" : nestedFieldName;
                        const f = fieldName.substring(10 + objecttype.length);

                        e.push({
                            "field": objecttype + "." + f + "[" + idx + "]." + n,
                            "message": `Error on  **${nestedFieldName}** with value, fields can only be empty`,
                            "parameters": {
                                a: "a",
                                b: "b",
                            }
                        });
                        nestedProblemsCount++;
                        problemsCount++;
                    }
                    idx++;
                });

                // For a validation error for the nested table itself we can use <subtable_name>[] as field name
                if(nestedProblemsCount>0) {
                    const newNestedFieldName = fieldName.substring(10 + objecttype.length) + "[]";
                    e.push({
                        "field": objecttype + "." + newNestedFieldName,
                        "message": `There are errors inside **${newNestedFieldName}**`,
                        "parameters": {
                            a: "a",
                            b: "b",
                        }
                    });
                };

            } else if (fieldName.startsWith("_reverse_nested") && fieldValue.length > 0) {
                // Reverse nested fields, the reverse nested is like _reverse_nested_<linked_table>:<field_name>
                const reverseTableName = fieldName.split(":")[1];
                const reverseFieldName = fieldName.split(":")[2];
                let reverseProblemsCount = 0;
                let idx = 0;
                fieldValue.forEach(nestedReversedObject => {
                    // We iterate the fields of the reverse nested object
                    for (const nestedFieldName in nestedReversedObject) {

                        if (nestedFieldName.startsWith("_")) {
                            continue;
                        }
                        if(nestedReversedObject[nestedFieldName] === null) {
                            continue
                        }
                        e.push({
                            "field": reverseTableName + "." + reverseFieldName + "[" + idx + "]." + nestedFieldName,
                            "message": `Error for  **${nestedFieldName}** in **${reverseFieldName}**, fields can only be empty`,
                        });
                        reverseProblemsCount++;
                    }
                    idx++;
                });

                if(reverseProblemsCount>0) {
                    e.push({
                        "field": reverseTableName + "." + reverseFieldName + "[]",
                        "message": `There is a problem on the field: **${fieldName}**`,
                    });
                }

            } else {
                if (Array.isArray(fieldValue) && fieldValue.length === 0) {
                    continue;
                }

                // Not nested fields
                e.push({
                    "field": objecttype + "." + fieldName,
                    "message": `The field **${fieldName}** only accepts empty values`,
                    "parameters": {
                        a: "a",
                        b: "b",
                    }
                });
                problemsCount++;
            }
        }
        return e;
    });

    if (problemsCount === 0) {
        console.log(JSON.stringify({"objects": []}));
        console.error("Validation ok");
        process.exit(0);
        return
    }

    console.log(JSON.stringify(
        {
            "code": "validation.plugin.error",
            "error": "Server Validation Error, see editor for details",
            "statuscode": 400,
            "parameters": {
                "problems": errors,
            }
        }
    ));
    console.error("This error goes to STDERR")
    process.exit(400);
});
