/*

Validation Errors dynamic example.

This is a dynamic validation error example, it will generate a validation error 
for each field for the objecttype "validation_errors"  (this is configured in the manifest.master.yml)
With this example you can easily test the validation error handling in the editor for all fields.

The general rules for the field names are:
 - Normal Fields : <objecttype_name>.<field_name>
 - Nested Fields : <objecttype_name>.<nested_field_name>[<index>].<sub_field_name>
 - Reversed nested tables : <reverse_objecttype_name>.<reverse_field_name>[<index>].<field_name>

 On nesteds if the "[]" is used without any number then we are referencing the nested field itself as a whole

An example of a response with validation errors generated by this script is:

{
    "code": "validation.plugin.error",
    "error": "Server Validation Error, see editor for details",
    "package": "",
    "parameters": {
        "problems": [
            [
                {
                    "field": "myobjecttype.field_list[0].subfield_1",
                    "message": "This is a validation error for field 'subfield_1' in the first position of the field_list nested",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.field_list[]",
                    "message": "This is a validation error for the field_list nested itself",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                },
                {
                    "field": "myobjecttype.name",
                    "message": "This is a validation error for the name field",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
                {
                    // Note that for reverse nested fields we use first the reverse objecttype name and then the reverse field name
                    "field": "otherObjectType.reverse_field[0].name",
                    "message": "This is a validation error for the field name in the first reverse_field of type otherObjectType",
                    "parameters": {
                        "a": "a",
                        "b": "b"
                    }
                }
            ]
        ]
    },
    "realm": "api",
    "statuscode": 400
}


*/



const fs = require('fs');


let input = '';
process.stdin.on('data', d => {
    try {
        input += d.toString();
    } catch(e) {
        console.error(`Could not read input into string: ${e.message}`, e.stack);
        process.exit(1);
    }
});


process.stdin.on('end', () => {
    // We get the objects being saved from input
    const objects = JSON.parse(input)?.objects;
    if (!objects || !objects.length > 0) {
        process.exit(1);
    }

    const objecttype = objects[0]["_objecttype"];
    let problemsCount = 0;
    const errors = objects.map(o => {
        let e = [];
        for (const fieldName in o[objecttype]) {
            if (fieldName.startsWith("_") && !fieldName.startsWith("_nested") && !fieldName.startsWith("_reverse_nested") ) {
                continue;
            }
            const fieldValue = o[objecttype][fieldName];
            if (fieldValue === null || fieldValue === undefined || fieldValue === "") {
                continue;
            }

            // Demo nested errors only for even indexes
            if (fieldName.startsWith("_nested") && fieldValue.length > 0) {
                let idx = 0;
                fieldValue.forEach(nestedObject => {
                    if (idx % 2 === 0) {
                        for (const nestedFieldName in nestedObject) {
                            const nestedFieldValue = nestedObject[nestedFieldName];
                            if (nestedFieldValue === null) {
                                continue;
                            }

                            const n = nestedFieldName.startsWith("_nested") ? nestedFieldName.substring(fieldName.length + 2) + "[]" : nestedFieldName;
                            const f = fieldName.substring(10 + objecttype.length);

                            e.push({
                                "field": objecttype + "." + f + "[" + idx + "]." + n,
                                "message": `This is a dummy error message for ${nestedFieldName} with value ${nestedFieldValue}, we only accept empty values here...`,
                                "parameters": {
                                    a: "a",
                                    b: "b",
                                }
                            });
                            problemsCount++;
                        }
                    }
                    idx++;
                });

                // For a validation error for the nested table itself we can use <subtable_name>[] as field name
                const newNestedFieldName = fieldName.substring(10 + objecttype.length) + "[]";
                e.push({
                    "field": objecttype + "." + newNestedFieldName,
                    "message": `This is a dummy error message for ${newNestedFieldName} with value ${fieldValue}, we only accept empty values here...`,
                    "parameters": {
                        a: "a",
                        b: "b",
                    }
                });

            } else if (fieldName.startsWith("_reverse_nested") && fieldValue.length > 0) {
                // Reverse nested fields, the reverse nested is like _reverse_nested_<linked_table>:<field_name>
                const reverseTableName = fieldName.split(":")[1];
                const reverseFieldName = fieldName.split(":")[2];
                e.push({
                    "field": reverseTableName + "." + reverseFieldName + "[]",
                    "message": `This is a dummy error message for the reverse nested field ${fieldName}`,
                });
                let idx = 0;
                fieldValue.forEach(nestedReversedObject => {
                    // We iterate the fields of the reverse nested object
                    for (const nestedFieldName in nestedReversedObject) {
                        if (nestedFieldName.startsWith("_")) {
                            continue;
                        }
                        e.push({
                            "field": reverseTableName + "." + reverseFieldName + "[" + idx + "]." + nestedFieldName,
                            "message": `This is a dummy error message for the reverse nested field ${nestedFieldName} in ${reverseFieldName}`,
                        });
                    }
                    idx++;
                });

            } else {
                // Not nested fields
                e.push({
                    "field": objecttype + "." + fieldName,
                    "message": `This is a dummy error message for ${fieldName} with value ${fieldValue}, we only accept empty values here...`,
                    "parameters": {
                        a: "a",
                        b: "b",
                    }
                });
                problemsCount++;
            }
        }
        return e;
    });

    if (problemsCount === 0) {
        console.log(JSON.stringify({"objects": []}));
        console.error("Validation ok");
        process.exit(0);
        return
    }

    console.log(JSON.stringify(
        {
            "code": "validation.plugin.error",
            "error": "Server Validation Error, see editor for details",
            "statuscode": 400,
            "parameters": {
                "problems": errors,
            }
        }
    ));
    console.error("This error goes to STDERR")
    process.exit(400);
});
